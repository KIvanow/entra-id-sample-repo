"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntraidCredentialsProvider = void 0;
/**
 * A streaming credentials provider that uses the Entraid identity provider to provide credentials.
 * Please use one of the factory functions in `entraid-credetfactories.ts` to create an instance of this class for the different
 * type of authentication flows.
 */
class EntraidCredentialsProvider {
    tokenManager;
    idp;
    options;
    type = 'streaming-credentials-provider';
    #listeners = new Set();
    #tokenManagerDisposable = null;
    #isStarting = false;
    #pendingSubscribers = [];
    constructor(tokenManager, idp, options = {}) {
        this.tokenManager = tokenManager;
        this.idp = idp;
        this.options = options;
        this.onReAuthenticationError = options.onReAuthenticationError ?? DEFAULT_ERROR_HANDLER;
        this.#credentialsMapper = options.credentialsMapper ?? DEFAULT_CREDENTIALS_MAPPER;
    }
    async subscribe(listener) {
        const currentToken = this.tokenManager.getCurrentToken();
        if (currentToken) {
            return [this.#credentialsMapper(currentToken.value), this.#createDisposable(listener)];
        }
        if (this.#isStarting) {
            return new Promise((resolve, reject) => {
                this.#pendingSubscribers.push({ resolve, reject, pendingListener: listener });
            });
        }
        this.#isStarting = true;
        try {
            const initialToken = await this.#startTokenManagerAndObtainInitialToken();
            this.#pendingSubscribers.forEach(({ resolve, pendingListener }) => {
                resolve([this.#credentialsMapper(initialToken.value), this.#createDisposable(pendingListener)]);
            });
            this.#pendingSubscribers = [];
            return [this.#credentialsMapper(initialToken.value), this.#createDisposable(listener)];
        }
        finally {
            this.#isStarting = false;
        }
    }
    onReAuthenticationError;
    #credentialsMapper;
    #createTokenManagerListener(subscribers) {
        return {
            onError: (error) => {
                if (!error.isRetryable) {
                    subscribers.forEach(listener => listener.onError(error));
                }
                else {
                    this.options.onRetryableError?.(error.message);
                }
            },
            onNext: (token) => {
                const credentials = this.#credentialsMapper(token.value);
                subscribers.forEach(listener => listener.onNext(credentials));
            }
        };
    }
    #createDisposable(listener) {
        this.#listeners.add(listener);
        return {
            dispose: () => {
                this.#listeners.delete(listener);
                if (this.#listeners.size === 0 && this.#tokenManagerDisposable) {
                    this.#tokenManagerDisposable.dispose();
                    this.#tokenManagerDisposable = null;
                }
            }
        };
    }
    async #startTokenManagerAndObtainInitialToken() {
        const initialResponse = await this.idp.requestToken();
        const token = this.tokenManager.wrapAndSetCurrentToken(initialResponse.token, initialResponse.ttlMs);
        this.#tokenManagerDisposable = this.tokenManager.start(this.#createTokenManagerListener(this.#listeners), this.tokenManager.calculateRefreshTime(token));
        return token;
    }
    hasActiveSubscriptions() {
        return this.#tokenManagerDisposable !== null && this.#listeners.size > 0;
    }
    getSubscriptionsCount() {
        return this.#listeners.size;
    }
    getTokenManager() {
        return this.tokenManager;
    }
    getCurrentCredentials() {
        const currentToken = this.tokenManager.getCurrentToken();
        return currentToken ? this.#credentialsMapper(currentToken.value) : null;
    }
}
exports.EntraidCredentialsProvider = EntraidCredentialsProvider;
const DEFAULT_CREDENTIALS_MAPPER = (token) => ({
    username: token.uniqueId,
    password: token.accessToken
});
const DEFAULT_ERROR_HANDLER = (error) => console.error('ReAuthenticationError', error);
//# sourceMappingURL=entraid-credentials-provider.js.map